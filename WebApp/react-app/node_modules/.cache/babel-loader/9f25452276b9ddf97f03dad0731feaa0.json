{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nvar core_1 = require(\"@aws-amplify/core\");\n\nvar MobileAnalytics = require(\"aws-sdk/clients/mobileanalytics\");\n\nvar Pinpoint = require(\"aws-sdk/clients/pinpoint\");\n\nvar cache_1 = require(\"@aws-amplify/cache\");\n\nvar uuid_1 = require(\"uuid\");\n\nvar AMPLIFY_SYMBOL = typeof Symbol !== 'undefined' && typeof Symbol.for === 'function' ? Symbol.for('amplify_default') : '@@amplify_default';\n\nvar dispatchAnalyticsEvent = function dispatchAnalyticsEvent(event, data) {\n  core_1.Hub.dispatch('analytics', {\n    event: event,\n    data: data\n  }, 'Analytics', AMPLIFY_SYMBOL);\n};\n\nvar logger = new core_1.ConsoleLogger('AWSPinpointProvider');\nvar NON_RETRYABLE_EXCEPTIONS = ['BadRequestException', 'SerializationException', 'ValidationException']; // events buffer\n\nvar BUFFER_SIZE = 1000;\nvar FLUSH_SIZE = 100;\nvar FLUSH_INTERVAL = 5 * 1000; // 5s\n\nvar RESEND_LIMIT = 5; // params: { event: {name: , .... }, timeStamp, config, resendLimits }\n\nvar AWSPinpointProvider =\n/** @class */\nfunction () {\n  function AWSPinpointProvider(config) {\n    this._buffer = [];\n    this._config = config ? config : {};\n    this._config.bufferSize = this._config.bufferSize || BUFFER_SIZE;\n    this._config.flushSize = this._config.flushSize || FLUSH_SIZE;\n    this._config.flushInterval = this._config.flushInterval || FLUSH_INTERVAL;\n    this._config.resendLimit = this._config.resendLimit || RESEND_LIMIT;\n    this._clientInfo = core_1.ClientDevice.clientInfo();\n  }\n\n  AWSPinpointProvider.prototype._setupTimer = function () {\n    var _this = this;\n\n    if (this._timer) {\n      clearInterval(this._timer);\n    }\n\n    var _a = this._config,\n        flushSize = _a.flushSize,\n        flushInterval = _a.flushInterval;\n    var that = this;\n    this._timer = setInterval(function () {\n      var size = _this._buffer.length < flushSize ? _this._buffer.length : flushSize;\n\n      for (var i = 0; i < size; i += 1) {\n        var params = _this._buffer.shift();\n\n        that._sendFromBuffer(params);\n      }\n    }, flushInterval);\n  };\n  /**\n   * @private\n   * @param params - params for the event recording\n   * Put events into buffer\n   */\n\n\n  AWSPinpointProvider.prototype._putToBuffer = function (params) {\n    var bufferSize = this._config.bufferSize;\n\n    if (this._buffer.length < bufferSize) {\n      this._buffer.push(params);\n\n      return Promise.resolve(true);\n    } else {\n      logger.debug('exceed analytics events buffer size');\n      return Promise.reject(false);\n    }\n  };\n\n  AWSPinpointProvider.prototype._sendFromBuffer = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var event, config, appId, region, resendLimit, success, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            event = params.event, config = params.config;\n            appId = config.appId, region = config.region, resendLimit = config.resendLimit;\n            success = true;\n            _a = event.name;\n\n            switch (_a) {\n              case '_session.start':\n                return [3\n                /*break*/\n                , 1];\n\n              case '_session.stop':\n                return [3\n                /*break*/\n                , 3];\n\n              case '_update_endpoint':\n                return [3\n                /*break*/\n                , 5];\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this._startSession(params)];\n\n          case 2:\n            success = _b.sent();\n            return [3\n            /*break*/\n            , 9];\n\n          case 3:\n            return [4\n            /*yield*/\n            , this._stopSession(params)];\n\n          case 4:\n            success = _b.sent();\n            return [3\n            /*break*/\n            , 9];\n\n          case 5:\n            return [4\n            /*yield*/\n            , this._updateEndpoint(params)];\n\n          case 6:\n            success = _b.sent();\n            return [3\n            /*break*/\n            , 9];\n\n          case 7:\n            return [4\n            /*yield*/\n            , this._recordCustomEvent(params)];\n\n          case 8:\n            success = _b.sent();\n            return [3\n            /*break*/\n            , 9];\n\n          case 9:\n            if (!success) {\n              params.resendLimits = typeof params.resendLimits === 'number' ? params.resendLimits : resendLimit;\n\n              if (params.resendLimits > 0) {\n                logger.debug(\"resending event \" + params.eventName + \" with \" + params.resendLimits + \" retry times left\");\n                params.resendLimits -= 1;\n\n                this._putToBuffer(params);\n              } else {\n                logger.debug(\"retry times used up for event \" + params.eventName);\n              }\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * get the category of the plugin\n   */\n\n\n  AWSPinpointProvider.prototype.getCategory = function () {\n    return AWSPinpointProvider.category;\n  };\n  /**\n   * get provider name of the plugin\n   */\n\n\n  AWSPinpointProvider.prototype.getProviderName = function () {\n    return AWSPinpointProvider.providerName;\n  };\n  /**\n   * configure the plugin\n   * @param {Object} config - configuration\n   */\n\n\n  AWSPinpointProvider.prototype.configure = function (config) {\n    var _this = this;\n\n    logger.debug('configure Analytics', config);\n    var conf = config ? config : {};\n    this._config = Object.assign({}, this._config, conf);\n\n    if (this._config['appId'] && !this._config['disabled']) {\n      if (!this._config['endpointId']) {\n        var cacheKey = this.getProviderName() + '_' + this._config['appId'];\n\n        this._getEndpointId(cacheKey).then(function (endpointId) {\n          logger.debug('setting endpoint id from the cache', endpointId);\n          _this._config['endpointId'] = endpointId;\n          dispatchAnalyticsEvent('pinpointProvider_configured', null);\n        }).catch(function (e) {\n          logger.debug('Failed to generate endpointId', e);\n        });\n      } else {\n        dispatchAnalyticsEvent('pinpointProvider_configured', null);\n      }\n\n      this._setupTimer();\n    } else {\n      if (this._timer) {\n        clearInterval(this._timer);\n      }\n    }\n\n    return this._config;\n  };\n  /**\n   * record an event\n   * @param {Object} params - the params of an event\n   */\n\n\n  AWSPinpointProvider.prototype.record = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var credentials, timestamp;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._getCredentials()];\n\n          case 1:\n            credentials = _a.sent();\n\n            if (!credentials || !this._config['appId'] || !this._config['region']) {\n              logger.debug('cannot send events without credentials, applicationId or region');\n              return [2\n              /*return*/\n              , Promise.resolve(false)];\n            }\n\n            timestamp = new Date().getTime(); // attach the session and eventId\n\n            this._generateSession(params);\n\n            params.event.eventId = uuid_1.v1();\n            Object.assign(params, {\n              timestamp: timestamp,\n              config: this._config,\n              credentials: credentials\n            }); // temporary solution, will refactor in the future\n\n            if (params.event.immediate) {\n              return [2\n              /*return*/\n              , this._send(params)];\n            } else {\n              return [2\n              /*return*/\n              , this._putToBuffer(params)];\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSPinpointProvider.prototype._generateSession = function (params) {\n    this._sessionId = this._sessionId || uuid_1.v1();\n    var event = params.event;\n\n    switch (event.name) {\n      case '_session.start':\n        // refresh the session id and session start time\n        this._sessionStartTimestamp = new Date().getTime();\n        this._sessionId = uuid_1.v1();\n        event.session = {\n          Id: this._sessionId,\n          StartTimestamp: new Date(this._sessionStartTimestamp).toISOString()\n        };\n        break;\n\n      case '_session.stop':\n        var stopTimestamp = new Date().getTime();\n        this._sessionStartTimestamp = this._sessionStartTimestamp || new Date().getTime();\n        this._sessionId = this._sessionId || uuid_1.v1();\n        event.session = {\n          Id: this._sessionId,\n          Duration: stopTimestamp - this._sessionStartTimestamp,\n          StartTimestamp: new Date(this._sessionStartTimestamp).toISOString(),\n          StopTimestamp: new Date(stopTimestamp).toISOString()\n        };\n        this._sessionId = undefined;\n        this._sessionStartTimestamp = undefined;\n        break;\n\n      default:\n        this._sessionStartTimestamp = this._sessionStartTimestamp || new Date().getTime();\n        this._sessionId = this._sessionId || uuid_1.v1();\n        event.session = {\n          Id: this._sessionId,\n          StartTimestamp: new Date(this._sessionStartTimestamp).toISOString()\n        };\n        break;\n    }\n  };\n\n  AWSPinpointProvider.prototype._send = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var event, config;\n      return __generator(this, function (_a) {\n        event = params.event, config = params.config;\n\n        switch (event.name) {\n          case '_session.start':\n            return [2\n            /*return*/\n            , this._startSession(params)];\n\n          case '_session.stop':\n            return [2\n            /*return*/\n            , this._stopSession(params)];\n\n          case '_update_endpoint':\n            return [2\n            /*return*/\n            , this._updateEndpoint(params)];\n\n          default:\n            return [2\n            /*return*/\n            , this._recordCustomEvent(params)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  AWSPinpointProvider.prototype._generateBatchItemContext = function (params) {\n    var event = params.event,\n        timestamp = params.timestamp,\n        config = params.config,\n        credentials = params.credentials;\n    var name = event.name,\n        attributes = event.attributes,\n        metrics = event.metrics,\n        eventId = event.eventId,\n        session = event.session;\n    var appId = config.appId,\n        endpointId = config.endpointId;\n    var endpointContext = {};\n    var eventParams = {\n      ApplicationId: appId,\n      EventsRequest: {\n        BatchItem: {}\n      }\n    };\n    eventParams.EventsRequest.BatchItem[endpointId] = {};\n    var endpointObj = eventParams.EventsRequest.BatchItem[endpointId];\n    endpointObj['Endpoint'] = endpointContext;\n    endpointObj['Events'] = {};\n    endpointObj['Events'][eventId] = {\n      EventType: name,\n      Timestamp: new Date(timestamp).toISOString(),\n      Attributes: attributes,\n      Metrics: metrics,\n      Session: session\n    };\n    return eventParams;\n  };\n\n  AWSPinpointProvider.prototype._pinpointPutEvents = function (eventParams) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        logger.debug('pinpoint put events with params', eventParams);\n        return [2\n        /*return*/\n        , new Promise(function (res, rej) {\n          var request = _this.pinpointClient.putEvents(eventParams); // in order to keep backward compatiblity\n          // we are using a legacy api: /apps/{appid}/events/legacy\n          // so that users don't need to update their IAM Policy\n          // will use the formal one in the next break release\n\n\n          request.on('build', function () {\n            request.httpRequest.path = request.httpRequest.path + '/legacy';\n          });\n          request.send(function (err, data) {\n            if (err) {\n              logger.error('record event failed. ', err);\n              logger.warn('If you have not updated your Pinpoint IAM Policy' + ' with the Action: \\\"mobiletargeting:PutEvents\\\" yet, please do it.' + ' This action is not necessary for now' + ' but in order to avoid breaking changes in the future,' + ' please update it as soon as possible.');\n              res(false);\n            } else {\n              logger.debug('record event success. ', data);\n              res(true);\n            }\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * @private\n   * @param params\n   */\n\n\n  AWSPinpointProvider.prototype._startSession = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var event, timestamp, config, credentials, eventParams;\n      return __generator(this, function (_a) {\n        event = params.event, timestamp = params.timestamp, config = params.config, credentials = params.credentials;\n\n        this._initClients(config, credentials);\n\n        logger.debug('record session start');\n        eventParams = this._generateBatchItemContext(params);\n        return [2\n        /*return*/\n        , this._pinpointPutEvents(eventParams)];\n      });\n    });\n  };\n  /**\n   * @private\n   * @param params\n   */\n\n\n  AWSPinpointProvider.prototype._stopSession = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var event, timestamp, config, credentials, eventParams;\n      return __generator(this, function (_a) {\n        event = params.event, timestamp = params.timestamp, config = params.config, credentials = params.credentials;\n\n        this._initClients(config, credentials);\n\n        logger.debug('record session stop');\n        eventParams = this._generateBatchItemContext(params);\n        return [2\n        /*return*/\n        , this._pinpointPutEvents(eventParams)];\n      });\n    });\n  };\n  /**\n   * @private\n   * @param params\n   */\n\n\n  AWSPinpointProvider.prototype._recordCustomEvent = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var event, timestamp, config, credentials, eventParams;\n      return __generator(this, function (_a) {\n        event = params.event, timestamp = params.timestamp, config = params.config, credentials = params.credentials;\n\n        this._initClients(config, credentials);\n\n        logger.debug('record event with params');\n        eventParams = this._generateBatchItemContext(params);\n        return [2\n        /*return*/\n        , this._pinpointPutEvents(eventParams)];\n      });\n    });\n  };\n\n  AWSPinpointProvider.prototype._updateEndpoint = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var timestamp, config, credentials, event, appId, region, endpointId, request, update_params, that;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        timestamp = params.timestamp, config = params.config, credentials = params.credentials, event = params.event;\n        appId = config.appId, region = config.region, endpointId = config.endpointId;\n\n        this._initClients(config, credentials);\n\n        request = this._endpointRequest(config, core_1.JS.transferKeyToLowerCase(event, [], ['attributes', 'userAttributes', 'Attributes', 'UserAttributes']));\n        update_params = {\n          ApplicationId: appId,\n          EndpointId: endpointId,\n          EndpointRequest: request\n        };\n        that = this;\n        logger.debug('updateEndpoint with params: ', update_params);\n        return [2\n        /*return*/\n        , new Promise(function (res, rej) {\n          that.pinpointClient.updateEndpoint(update_params, function (err, data) {\n            if (err) {\n              logger.debug('updateEndpoint failed', err);\n\n              if (err.message === 'Exceeded maximum endpoint per user count 10') {\n                _this._removeUnusedEndpoints(appId, request.User.UserId).then(function () {\n                  logger.debug('Remove the unused endpoints successfully');\n                  return res(false);\n                }).catch(function (e) {\n                  logger.warn(\"Failed to remove unused endpoints with error: \" + e);\n                  logger.warn(\"Please ensure you have updated your Pinpoint IAM Policy \" + \"with the Action: \\\"mobiletargeting:GetUserEndpoints\\\" \" + \"in order to get endpoints info of the user\");\n                  return res(false);\n                });\n              }\n\n              return res(false);\n            } else {\n              logger.debug('updateEndpoint success', data);\n              return res(true);\n            }\n          });\n        })];\n      });\n    });\n  };\n\n  AWSPinpointProvider.prototype._removeUnusedEndpoints = function (appId, userId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (res, rej) {\n          _this.pinpointClient.getUserEndpoints({\n            ApplicationId: appId,\n            UserId: userId\n          }, function (err, data) {\n            if (err) {\n              logger.debug(\"Failed to get endpoints associated with the userId: \" + userId + \" with error\", err);\n              return rej(err);\n            }\n\n            var endpoints = data.EndpointsResponse.Item;\n            logger.debug(\"get endpoints associated with the userId: \" + userId + \" with data\", endpoints);\n            var endpointToBeDeleted = endpoints[0];\n\n            for (var i = 1; i < endpoints.length; i++) {\n              var timeStamp1 = Date.parse(endpointToBeDeleted['EffectiveDate']);\n              var timeStamp2 = Date.parse(endpoints[i]['EffectiveDate']); // delete the one with invalid effective date\n\n              if (isNaN(timeStamp1)) break;\n\n              if (isNaN(timeStamp2)) {\n                endpointToBeDeleted = endpoints[i];\n                break;\n              }\n\n              if (timeStamp2 < timeStamp1) {\n                endpointToBeDeleted = endpoints[i];\n              }\n            } // update the endpoint's user id with an empty string\n\n\n            var update_params = {\n              ApplicationId: appId,\n              EndpointId: endpointToBeDeleted['Id'],\n              EndpointRequest: {\n                User: {\n                  UserId: ''\n                }\n              }\n            };\n\n            _this.pinpointClient.updateEndpoint(update_params, function (err, data) {\n              if (err) {\n                logger.debug('Failed to update the endpoint', err);\n                return rej(err);\n              }\n\n              logger.debug('The old endpoint is updated with an empty string for user id');\n              return res(data);\n            });\n          });\n        })];\n      });\n    });\n  };\n  /**\n   * @private\n   * @param config\n   * Init the clients\n   */\n\n\n  AWSPinpointProvider.prototype._initClients = function (config, credentials) {\n    return __awaiter(this, void 0, void 0, function () {\n      var region;\n      return __generator(this, function (_a) {\n        logger.debug('init clients');\n\n        if (this.mobileAnalytics && this.pinpointClient && this._config.credentials && this._config.credentials.sessionToken === credentials.sessionToken && this._config.credentials.identityId === credentials.identityId) {\n          logger.debug('no change for aws credentials, directly return from init');\n          return [2\n          /*return*/\n          ];\n        }\n\n        this._config.credentials = credentials;\n        region = config.region;\n        logger.debug('init clients with credentials', credentials);\n        this.mobileAnalytics = new MobileAnalytics({\n          credentials: credentials,\n          region: region\n        });\n        this.pinpointClient = new Pinpoint({\n          region: region,\n          credentials: credentials\n        });\n\n        if (core_1.Platform.isReactNative) {\n          this.pinpointClient.customizeRequests(function (request) {\n            request.on('build', function (req) {\n              req.httpRequest.headers['user-agent'] = core_1.Platform.userAgent;\n            });\n          });\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  AWSPinpointProvider.prototype._getEndpointId = function (cacheKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var endpointId;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , cache_1.default.getItem(cacheKey)];\n\n          case 1:\n            endpointId = _a.sent();\n            logger.debug('endpointId from cache', endpointId, 'type', typeof endpointId);\n\n            if (!endpointId) {\n              endpointId = uuid_1.v1();\n              cache_1.default.setItem(cacheKey, endpointId);\n            }\n\n            return [2\n            /*return*/\n            , endpointId];\n        }\n      });\n    });\n  };\n  /**\n   * EndPoint request\n   * @return {Object} - The request of updating endpoint\n   */\n\n\n  AWSPinpointProvider.prototype._endpointRequest = function (config, event) {\n    var credentials = config.credentials;\n    var clientInfo = this._clientInfo || {};\n    var clientContext = config.clientContext || {}; // for now we have three different ways for default endpoint configurations\n    // clientInfo\n    // clientContext (deprecated)\n    // config.endpoint\n\n    var defaultEndpointConfig = config.endpoint || {};\n    var demographicByClientInfo = {\n      appVersion: clientInfo.appVersion,\n      make: clientInfo.make,\n      model: clientInfo.model,\n      modelVersion: clientInfo.version,\n      platform: clientInfo.platform\n    }; // for backward compatibility\n\n    var clientId = clientContext.clientId,\n        appTitle = clientContext.appTitle,\n        appVersionName = clientContext.appVersionName,\n        appVersionCode = clientContext.appVersionCode,\n        appPackageName = clientContext.appPackageName,\n        demographicByClientContext = __rest(clientContext, [\"clientId\", \"appTitle\", \"appVersionName\", \"appVersionCode\", \"appPackageName\"]);\n\n    var channelType = event.address ? clientInfo.platform === 'android' ? 'GCM' : 'APNS' : undefined;\n\n    var tmp = __assign({\n      channelType: channelType,\n      requestId: uuid_1.v1(),\n      effectiveDate: new Date().toISOString()\n    }, defaultEndpointConfig, event, {\n      attributes: __assign({}, defaultEndpointConfig.attributes, event.attributes),\n      demographic: __assign({}, demographicByClientInfo, demographicByClientContext, defaultEndpointConfig.demographic, event.demographic),\n      location: __assign({}, defaultEndpointConfig.location, event.location),\n      metrics: __assign({}, defaultEndpointConfig.metrics, event.metrics),\n      user: {\n        userId: event.userId || defaultEndpointConfig.userId || credentials.identityId,\n        userAttributes: __assign({}, defaultEndpointConfig.userAttributes, event.userAttributes)\n      }\n    }); // eliminate unnecessary params\n\n\n    var userId = tmp.userId,\n        userAttributes = tmp.userAttributes,\n        name = tmp.name,\n        session = tmp.session,\n        eventId = tmp.eventId,\n        immediate = tmp.immediate,\n        ret = __rest(tmp, [\"userId\", \"userAttributes\", \"name\", \"session\", \"eventId\", \"immediate\"]);\n\n    return core_1.JS.transferKeyToUpperCase(ret, [], ['metrics', 'userAttributes', 'attributes']);\n  };\n  /**\n   * @private\n   * check if current credentials exists\n   */\n\n\n  AWSPinpointProvider.prototype._getCredentials = function () {\n    var that = this;\n    return core_1.Credentials.get().then(function (credentials) {\n      if (!credentials) return null;\n      logger.debug('set credentials for analytics', credentials);\n      return core_1.Credentials.shear(credentials);\n    }).catch(function (err) {\n      logger.debug('ensure credentials error', err);\n      return null;\n    });\n  };\n\n  AWSPinpointProvider.category = 'Analytics';\n  AWSPinpointProvider.providerName = 'AWSPinpoint';\n  return AWSPinpointProvider;\n}();\n\nexports.default = AWSPinpointProvider;","map":null,"metadata":{},"sourceType":"script"}